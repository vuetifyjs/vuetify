{"version":3,"sources":["../../src/mixins/maskable.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * Maskable\n *\n * @mixin\n *\n * Creates an input mask that is\n * generated from a masked str\n *\n * Example: mask=\"#### #### #### ####\"\n */\n\nimport {\n  isMaskDelimiter,\n  maskText,\n  unmaskText\n} from '../util/mask'\n\n/* @vue/component */\nexport default {\n  name: 'maskable',\n\n  props: {\n    dontFillMaskBlanks: Boolean,\n    mask: {\n      type: [Object, String],\n      default: null\n    },\n    returnMaskedValue: Boolean\n  },\n\n  data: () => ({\n    selection: 0,\n    lazySelection: 0,\n    preDefined: {\n      'credit-card': '#### - #### - #### - ####',\n      'date': '##/##/####',\n      'date-with-time': '##/##/#### ##:##',\n      'phone': '(###) ### - ####',\n      'social': '###-##-####',\n      'time': '##:##',\n      'time-with-seconds': '##:##:##'\n    }\n  }),\n\n  computed: {\n    masked () {\n      const preDefined = this.preDefined[this.mask]\n      const mask = preDefined || this.mask || ''\n\n      return mask.split('')\n    }\n  },\n\n  watch: {\n    /**\n     * Make sure the cursor is in the correct\n     * location when the mask changes\n     */\n    mask () {\n      if (!this.$refs.input) return\n\n      const oldValue = this.$refs.input.value\n      const newValue = this.maskText(unmaskText(this.lazyValue))\n      let position = 0\n      let selection = this.selection\n\n      for (let index = 0; index < selection; index++) {\n        isMaskDelimiter(oldValue[index]) || position++\n      }\n\n      selection = 0\n      if (newValue) {\n        for (let index = 0; index < newValue.length; index++) {\n          isMaskDelimiter(newValue[index]) || position--\n          selection++\n          if (position <= 0) break\n        }\n      }\n\n      this.$nextTick(() => {\n        this.$refs.input.value = newValue\n        this.setCaretPosition(selection)\n      })\n    }\n  },\n\n  beforeMount () {\n    if (!this.mask ||\n      this.value == null ||\n      !this.returnMaskedValue\n    ) return\n\n    const value = this.maskText(this.value)\n\n    // See if masked value does not\n    // match the user given value\n    if (value === this.value) return\n\n    this.$emit('input', value)\n  },\n\n  methods: {\n    setCaretPosition (selection) {\n      this.selection = selection\n      window.setTimeout(() => {\n        this.$refs.input && this.$refs.input.setSelectionRange(this.selection, this.selection)\n      }, 0)\n    },\n    updateRange () {\n      if (!this.$refs.input) return\n\n      const newValue = this.maskText(this.lazyValue)\n      let selection = 0\n\n      this.$refs.input.value = newValue\n      if (newValue) {\n        for (let index = 0; index < newValue.length; index++) {\n          if (this.lazySelection <= 0) break\n          isMaskDelimiter(newValue[index]) || this.lazySelection--\n          selection++\n        }\n      }\n\n      this.setCaretPosition(selection)\n      // this.$emit() must occur only when all internal values are correct\n      this.$emit('input', this.returnMaskedValue ? this.$refs.input.value : this.lazyValue)\n    },\n    maskText (text) {\n      return this.mask ? maskText(text, this.masked, this.dontFillMaskBlanks) : text\n    },\n    unmaskText (text) {\n      return this.mask && !this.returnMaskedValue ? unmaskText(text) : text\n    },\n    // When the input changes and is\n    // re-created, ensure that the\n    // caret location is correct\n    setSelectionRange () {\n      this.$nextTick(this.updateRange)\n    },\n    resetSelections (input) {\n      if (!input.selectionEnd) return\n      this.selection = input.selectionEnd\n      this.lazySelection = 0\n\n      for (let index = 0; index < this.selection; index++) {\n        isMaskDelimiter(input.value[index]) || this.lazySelection++\n      }\n    }\n  }\n}\n"],"sourceRoot":""}